name: Pull Request Validation

on:
  pull_request:
    branches: [ main ]

jobs:
  validate-and-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python 3.10
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Set COMPOSE_PROJECT_PATH for CI environment
        # This tells docker compose where the project root is, important for build contexts
        # and consistent behavior when docker-compose.tests.yml is in a subdirectory.
        run: echo "COMPOSE_PROJECT_PATH=$(pwd)" >> $GITHUB_ENV

      - name: Set up Docker Buildx (may ensure docker compose is available)
        uses: docker/setup-buildx-action@v3

      - name: Force Rebuild Test Images (no cache)
        # Explicitly build the nether-bridge and tester images without cache.
        # This forces them to pick up any code changes.
        run: |
          docker compose -f tests/docker-compose.tests.yml build --no-cache nether-bridge tester

      - name: Start Test Environment
        # Now, bring up all services. They will use the freshly built images.
        run: |
          docker compose -f tests/docker-compose.tests.yml up -d --remove-orphans
        id: start-env # Add an ID to reference this step later

      - name: Show Directory Structure Inside Tester Container
        run: |
          echo "Listing files and directory structure inside the 'tester' container at /app..."
          docker compose -f tests/docker-compose.tests.yml exec -T tester ls -lR /app

      - name: Run all tests
        run: |
          PROXY_IP=$(docker inspect nether-bridge | jq -r '.[0].NetworkSettings.Networks | .[] | .IPAddress')
          echo "Found nether-bridge IP: ${PROXY_IP}"
          docker compose -f tests/docker-compose.tests.yml exec -T tester env PROXY_IP=${PROXY_IP} python -m pytest --cov=nether_bridge --cov-report term-missing --compose-file /app/tests/docker-compose.tests.yml
        id: run-tests # Add an ID to reference this step

      - name: Dump All Container Logs on Failure
        # This step will run ALWAYS, and dump logs if the 'start-env' or 'run-tests' steps failed.
        # It's crucial to put this *before* the teardown.
        if: ${{ failure() || steps['start-env'].outcome == 'failure' || steps['run-tests'].outcome == 'failure' }}
        run: |
          echo "--- DUMPING ALL CONTAINER LOGS DUE TO FAILURE ---"
          echo "--- nether-bridge logs ---"
          docker logs nether-bridge || true # `|| true` prevents this step from failing if container already removed/non-existent
          echo "--- mc-bedrock logs ---"
          docker logs mc-bedrock || true
          echo "--- mc-java logs ---"
          docker logs mc-java || true
          echo "--- tester logs ---"
          docker logs tests-tester-1 || true
          echo "--- Docker Compose PS (all containers) ---"
          docker compose -f tests/docker-compose.tests.yml ps -a
          echo "--- Docker Compose logs (all services) ---"
          docker compose -f tests/docker-compose.tests.yml logs
          echo "--- END LOG DUMP ---"

      - name: Tear down test environment
        if: always() # Ensure teardown always runs, even if previous steps failed
        run: |
          echo "Tearing down Docker Compose environment..."
          docker compose -f tests/docker-compose.tests.yml down -v --remove-orphans